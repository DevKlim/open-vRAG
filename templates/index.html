<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vChat Interface</title>
    <link rel="stylesheet" href="{{ url_for('static', path='/style.css') }}">
</head>
<body>
    <div class="container">
        <div class="header">
             <h1>vChat: Ask Questions About Videos</h1>
        </div>
        <p class="subtitle">Enter a video URL and a question to analyze its content.</p>
        
        <form id="vchat-form">
            <div class="form-grid">
                <div class="form-group">
                    <label for="video_url">Video URL</label>
                    <input type="url" id="video_url" name="video_url" value="https://www.youtube.com/watch?v=XHTskNem4co" required>
                </div>
                <div class="form-group">
                    <label for="model_selection">Select Model</label>
                    <select id="model_selection" name="model_selection" {% if not custom_model_available %}disabled{% endif %}>
                        <option value="default">Default Model</option>
                        {% if custom_model_available %}
                        <option value="custom">Custom Fine-tuned</option>
                        {% endif %}
                    </select>
                     {% if not custom_model_available %}
                        <small>Run `finetune.py` to enable custom model.</small>
                    {% endif %}
                </div>
            </div>

            <div class="form-group">
                <label for="question">Your Question</label>
                <textarea id="question" name="question" rows="3" required>What is the animal in the video doing?</textarea>
            </div>
            
            <details class="advanced-options">
                <summary>Advanced Configuration</summary>
                <div class="options-grid">
                    <div class="form-group"><label for="num_perceptions">Perception Iterations</label><input type="number" id="num_perceptions" name="num_perceptions" value="3" min="1" max="10"></div>
                    <div class="form-group"><label for="sampling_fps">Sampling FPS</label><input type="number" id="sampling_fps" name="sampling_fps" value="2.0" min="0.1" max="30.0" step="0.1"></div>
                    <div class="form-group"><label for="max_new_tokens">Max New Tokens</label><input type="number" id="max_new_tokens" name="max_new_tokens" value="2048" min="1" step="64"></div>
                    <div class="form-group"><label for="temperature">Temperature</label><input type="number" id="temperature" name="temperature" value="0.7" min="0.0" max="2.0" step="0.1"></div>
                    <div class="form-group"><label for="top_p">Top-P</label><input type="number" id="top_p" name="top_p" value="0.9" min="0.0" max="1.0" step="0.05"></div>
                    <div class="form-group"><label for="repetition_penalty">Repetition Penalty</label><input type="number" id="repetition_penalty" name="repetition_penalty" value="1.1" min="1.0" max="2.0" step="0.05"></div>
                </div>
                 <div class="form-group"><label for="prompt_glue">Iterative Prompt (with &lt;glue&gt;)</label><textarea id="prompt_glue" name="prompt_glue" rows="6">Answer the question: "[QUESTION]" according to the content of the video. 
Output your think process within the <think> </think> tags.
Then, provide your answer within the <answer> </answer> tags. At the same time, in the <glue> </glue> tags, present the precise time period in seconds of the video clips on which you base your answer in the format of [(s1, e1), (s2, e2), ...]. For example: <think>...</think><answer>A</answer><glue>[(5.2, 10.4)]</glue>.</textarea></div>
                <div class="form-group"><label for="prompt_final">Final Prompt (no &lt;glue&gt;)</label><textarea id="prompt_final" name="prompt_final" rows="6">Answer the question: "[QUESTION]" according to the content of the video.
Output your think process within the <think> </think> tags.
Then, provide your answer within the <answer> </answer> tags. For example: <think>...</think><answer>A</answer>.</textarea></div>
            </details>
            <button type="submit" id="submit-btn">Analyze Video</button>
        </form>

        <div class="output-container">
            <h2>Processing Log & Results</h2>
            <pre id="output-log">Awaiting input...</pre>
        </div>
    </div>

    <script>
        const form = document.getElementById('vchat-form');
        const submitBtn = document.getElementById('submit-btn');
        const outputLog = document.getElementById('output-log');

        // --- NEW FIX ---
        // Automatically open the advanced options if an input inside is invalid.
        // This allows the browser to focus on the invalid field and show the error.
        form.addEventListener('invalid', (event) => {
            const invalidInput = event.target;
            const detailsParent = invalidInput.closest('details');
            if (detailsParent && !detailsParent.open) {
                detailsParent.open = true;
            }
        }, true); // Use the capture phase to catch the event early.
        // --- END FIX ---

        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Processing...';
            outputLog.textContent = 'Initializing request...';

            const formData = new FormData(form);

            try {
                // For debugging: log the data being sent
                console.log('Submitting form data:', Object.fromEntries(formData.entries()));

                const response = await fetch('/process', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error response:', errorText);
                    throw new Error(`Server responded with status ${response.status}: ${errorText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                outputLog.textContent = ''; // Clear "Initializing..."
                let buffer = '';
                let streamClosedByServer = false;

                while (!streamClosedByServer) {
                    const { value, done } = await reader.read();
                    if (done) {
                        console.log('Reader has been closed.');
                        break;
                    }
                    
                    buffer += decoder.decode(value, { stream: true });
                    
                    const messages = buffer.split('\n\n');
                    // The last element might be an incomplete message, so we keep it in the buffer.
                    buffer = messages.pop() || ''; 

                    for (const message of messages) {
                        if (!message) continue;

                        console.log("Received raw message:", JSON.stringify(message));

                        if (message.startsWith('event: close')) {
                            console.log('Server sent close event. Terminating stream processing.');
                            streamClosedByServer = true;
                            break; 
                        }

                        if (message.startsWith('data:')) {
                            let data = message.substring(5).trim();
                            
                            // Handle carriage return for progress updates on the same line
                            if (data.includes('\r')) {
                                const lines = outputLog.textContent.split('\n');
                                lines[lines.length - 1] = data.replace(/\r/g, '');
                                outputLog.textContent = lines.join('\n');
                            } else {
                                outputLog.textContent += data;
                            }
                            // Auto-scroll to the bottom
                            outputLog.scrollTop = outputLog.scrollHeight;
                        }
                    }
                }

                outputLog.textContent += '\n\n--- Stream finished ---';
                console.log('Stream processing finished successfully.');

            } catch (error) {
                console.error('An error occurred during the process:', error);
                // Ensure the error message is clearly visible to the user in the log.
                outputLog.textContent += `\n\n[CLIENT-SIDE ERROR]\nAn error occurred while processing the request.\nDetails: ${error.message}`;
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Analyze Video';
            }
        });
    </script>
</body>
</html>
